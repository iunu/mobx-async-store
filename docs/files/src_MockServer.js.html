<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/MockServer.js - mobx-async-store</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="mobx-async-store" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 4.3.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/FactoryFarm.html">FactoryFarm</a></li>
                                <li><a href="../classes/MockServer.html">MockServer</a></li>
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/RelatedRecordsArray.html">RelatedRecordsArray</a></li>
                                <li><a href="../classes/Schema.html">Schema</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/MockServer.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* global fetch Response */
import FactoryFarm from &#x27;./FactoryFarm&#x27;
import { serverResponse } from &#x27;./testUtils&#x27;

const simulatePost = (store, type, body) =&gt; {
  const { attributes } = JSON.parse(body.toString()).data
  const id = String(store.getAll(type).length + 1)

  const attributesWithId = { ...attributes, id }

  return store.add(type, attributesWithId)
}

const simulatePatch = (store, type, body) =&gt; {
  const { data } = JSON.parse(body.toString())
  const record = store.getOne(type, String(data.id))
  record.updateAttributesFromResponse(data)
  return record
}

const getOneFromFactory = (_backendFactoryFarm, factory, type, id) =&gt; {
  factory =
    factory ||
    Object.keys(_backendFactoryFarm.factories).find(
      (factoryName) =&gt; _backendFactoryFarm.factories[factoryName].type === type
    )
  if (!factory) {
    throw new Error(&#x60;No default factory for ${type} exists&#x60;)
  }
  return _backendFactoryFarm.build(factory, { id })
}

/**
 * Will throw an error if &#x60;fetch&#x60; is called from the mockServer, usually due to a &#x60;POST&#x60; or &#x60;PATCH&#x60; called by a &#x60;save&#x60;
 * @method circularFetchError
 * @param {String} url
 */
const circularFetchError = (url, options) =&gt; {
  throw new Error(
    &#x60;You tried to call fetch from MockServer with ${options.method} ${url}, which is circular and would call itself. This was caused by calling a method such as &#x27;save&#x27; on a model that was created from MockServer. To fix the problem, use FactoryFarm without MockServer&#x60;
  )
}

/**
 * Throws an error if MockServer tries to &#x60;findOne&#x60; or &#x60;findAll&#x60; from itself.
 * @method circularFindError
 * @param {String} type
 * @param {String} id
 */
const circularFindError = (type, id) =&gt; {
  const idText = id ? &#x60; with id ${id}&#x60; : &#x27;&#x27;
  throw new Error(
    &#x60;You tried to find ${type}${idText} from MockServer which is circular and would call itself. To fix the problem, use FactoryFarm without MockServer&#x60;
  )
}

/**
 * Overrides store methods that could trigger a &#x60;fetch&#x60; to throw errors. MockServer should only provide data for fetches, never call a fetch itself.
 * @method disallowFetches
 * @param {Object} store
 */
const disallowFetches = (store) =&gt; {
  store.fetch = circularFetchError
  store.findOne = circularFindError
  store.findAll = circularFindError
  store.findMany = circularFindError
  store.fetchOne = circularFindError
  store.fetchAll = circularFindError
  store.fetchMany = circularFindError
}

const serverFailureStatuses = [500]

/**
 * Wraps response JSON or object as needed. For a server failure (500), returns Promise.reject
 * For any other request, returns Promise.resolve wrapped around a Response object.
 * @method wrapResponse
 * @param {*} response JSON string unless a 500 error, in which case it&#x27;s an object
 * @param {String} method
 * @param {Number} status
 * @return {Promise}
 */

const wrapResponse = (response, method, status) =&gt; {
  if (!status) {
    status = method === &#x27;POST&#x27; ? 201 : 200
  }

  // Simulate the server itself fails
  if (serverFailureStatuses.includes(status)) {
    return Promise.reject(response)
  }

  return Promise.resolve(new Response(response, { status }))
}

/**
 * A backend &quot;server&quot; to be used for creating jsonapi-compliant responses.
 * @class MockServer
 */
class MockServer {
  /**
   * Sets properties needed internally
   * factoryFarm can be passed into the constructor
   * @method constructor
   * @param {*} param
   */
  constructor (options = {}) {
    this._backendFactoryFarm = options.factoryFarm || new FactoryFarm()
    this._backendFactoryFarm.__usedForMockServer__ = true
    this._backendFactoryFarm.store.__usedForMockServer__ = true

    disallowFetches(this._backendFactoryFarm.store)
  }

  /**
   * Sets up fetch mocking to intercept requests. It will then either use overrides, or use its own
   * internal store to simulate serving JSON responses of new data.
   *   - responseOverrides: An array of alternative responses that can be used to override the ones that would be served
   *     from the internal store.
   *   - factoriesForTypes: A key map that can be used to build factories if a queried id does not exist
   * @method start
   * @param {Object} options currently &#x60;responseOverrides&#x60; and &#x60;factoriesForTypes&#x60;
   */
  start = (options = {}) =&gt; {
    const { responseOverrides = [], factoriesForTypes } = options

    fetch.resetMocks()
    fetch.mockResponse((req) =&gt; {
      const foundQuery = responseOverrides.find((definition) =&gt; {
        if (!definition?.path) {
          throw new Error(&#x27;No path defined for mock server override. Did you define a path?&#x27;)
        }

        const method = definition.method || &#x27;GET&#x27;
        return req.url.match(definition.path) &amp;&amp; req.method.match(method)
      })

      const response = foundQuery
        ? foundQuery.response(this)
        : serverResponse(this._findFromStore(req, factoriesForTypes))

      return wrapResponse(response, req.method, foundQuery?.status)
    })
  }

  /**
   * Clears mocks and the store
   * @method stop
   */
  stop = () =&gt; {
    fetch.resetMocks()
    this._backendFactoryFarm.store.reset()
  }

  /**
   * Alias for &#x60;this._backendFactoryFarm.build&#x60;
   * @method build
   * @param {String} factoryName the name of the factory to use
   * @param {Object} overrideOptions overrides for the factory
   * @param {Number} numberOfRecords optional number of models to build
   * @return {*} Object or Array
   */
  build = (...params) =&gt; this._backendFactoryFarm.build(...params)

  /**
   * Alias for &#x60;this._backendFactoryFarm.define&#x60;
   * @method define
   * @param {String} name the name to use for the factory
   * @param {Object} options
   * @return {*} Object or Array
   */
  define = (...params) =&gt; this._backendFactoryFarm.define(...params)

  /**
   * Alias for &#x60;this._backendFactoryFarm.add&#x60;
   * @method add
   * @param {String} name the name to use for the factory
   * @param {Object} options
   * @return {*} Object or Array
   */
  add = (...params) =&gt; this._backendFactoryFarm.add(...params)

  /**
   * Based on a request, simulates building a response, either using found data
   * or a factory.
   * @method _findFromStore
   * @param {*} req
   * @return {Object} the found or built store record(s)
   * @private
   */
  _findFromStore = (req, factoriesForTypes = {}) =&gt; {
    const { _backendFactoryFarm } = this
    const { method, url, body } = req
    const { store } = _backendFactoryFarm

    const { pathname } = new URL(url, &#x27;http://example.com&#x27;)

    const type = Object.keys(store.schema.structure).find((model_type) =&gt; pathname.match(model_type))
    let id = pathname.match(/\d+$/)
    id = id &amp;&amp; String(id)

    if (method === &#x27;POST&#x27;) {
      return simulatePost(store, type, body)
    } else if (method === &#x27;PATCH&#x27;) {
      return simulatePatch(store, type, body)
    } else if (id) {
      return store.getOne(type, id) || getOneFromFactory(_backendFactoryFarm, factoriesForTypes[type], type, id)
    } else {
      const records = store.getAll(type)
      return records.length &gt; 0
        ? records
        : (factoriesForTypes[type] &amp;&amp; [getOneFromFactory(_backendFactoryFarm, factoriesForTypes[type], type, &#x27;1&#x27;)]) ||
            []
    }
  }
}

export default MockServer

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
