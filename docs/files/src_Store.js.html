<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/Store.js - mobx-async-store</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="mobx-async-store" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 4.1.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Model.html">Model</a></li>
                                <li><a href="../classes/RelatedRecordsArray.html">RelatedRecordsArray</a></li>
                                <li><a href="../classes/Schema.html">Schema</a></li>
                                <li><a href="../classes/Store.html">Store</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/Store.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* global fetch */
import { action, makeObservable, observable, runInAction, set, toJS } from &#x27;mobx&#x27;
import pick from &#x27;lodash/pick&#x27;
import uniqBy from &#x27;lodash/uniqBy&#x27;
import {
  combineRacedRequests,
  idOrNewId,
  deriveIdQueryStrings,
  parseErrorPointer,
  requestUrl
} from &#x27;./utils&#x27;
import schema from &#x27;./schema&#x27;

/**
 * Defines the Artemis Data Store class.
 *
 * @class Store
 * @constructor
 */
class Store {
  /**
   * Observable property used to store data and
   * handle changes to state
   *
   * @property data
   * @type {Object}
   * @default {}
   */
  @observable data = {}

  /**
   * Observable property used to store values for most recent response headers
   * according to settings specified as &#x60;headersOfInterest&#x60;
   *
   * @property lastResponseHeaders
   * @type {Object}
   * @default {}
   */
  @observable lastResponseHeaders = {}

  /**
   * Map(key: queryTag, value: Set([{ url, type, queryParams, queryTag }]))
   * @property loadingStates
   * @type {Map}
   */
  loadingStates = observable.map()

  genericErrorMessage = &#x27;Something went wrong.&#x27;

  /**
   * Initializer for Store class
   *
   * @method constructor
   */
  constructor (options) {
    makeObservable(this)
    this.init(options)
    this.schema = schema
  }

  /**
   * Adds an instance or an array of instances to the store.
   * &#x60;&#x60;&#x60;
   * kpiHash = { name: &quot;A good thing to measure&quot; }
   * kpi = store.add(&#x27;kpis&#x27;, kpiHash)
   * kpi.name
   * =&gt; &quot;A good thing to measure&quot;
   * &#x60;&#x60;&#x60;
   * @method add
   * @param {String} type
   * @param {Object} properties the properties to use
   * @return {Object} the new record
   */
  add = (type, data) =&gt; {
    if (data.constructor.name === &#x27;Array&#x27;) {
      return this.addModels(type, data)
    } else {
      return this.addModel(type, toJS(data))
    }
  }

  /**
   * Given a set of properties and type, returns an object with only the properties
   * that are defined as attributes in the schema for that type.
   * &#x60;&#x60;&#x60;
   * properties = { title: &#x27;Do laundry&#x27;, unrelatedProperty: &#x27;Do nothing&#x27; }
   * pickAttributes(properties, &#x27;todos&#x27;)
   * =&gt; { title: &#x27;Do laundry&#x27; }
   * &#x60;&#x60;&#x60;
   * @method pickAttributes
   * @param {Object} properties
   * @param {String} type
   * @return {Object}
   */
  pickAttributes = (properties, type) =&gt; {
    const attributeNames = Object.keys(this.schema.structure[type])
    return pick(properties, attributeNames)
  }

  /**
   * Given a set of properties and type, returns an object with only the properties
   * that are defined as relationships in the schema for that type.
   * &#x60;&#x60;&#x60;
   * properties = { notes: [note1, note2], category: cat1, title: &#x27;Fold Laundry&#x27; }
   * pickRelationships(properties, &#x27;todos&#x27;)
   * =&gt; {
   *       notes: {
   *         data: [{ id: &#x27;1&#x27;, type: &#x27;notes&#x27; }, { id: &#x27;2&#x27;, type: &#x27;notes&#x27; }]
   *       },
   *       category: {
   *         data: { id: &#x27;1&#x27;, type: &#x27;categories&#x27; }
   *       }
   *    }
   * &#x60;&#x60;&#x60;
   * @method pickRelationships
   * @param {Object} properties
   * @param {String} type
   * @return {Object}
   */
  pickRelationships = (properties, type) =&gt; {
    const relationshipNames = Object.keys(this.schema.relations[type] || {})
    const allRelationships = pick(properties, relationshipNames)

    return Object.keys(allRelationships).reduce((references, key) =&gt; {
      const relatedModel = allRelationships[key]
      let data
      if (Array.isArray(relatedModel)) {
        data = relatedModel.map((model) =&gt; ({
          id: model.id,
          type: model.type
        }))
      } else {
        data = { id: relatedModel.id, type: relatedModel.type }
      }
      references[key] = { data }
      return references
    }, {})
  }

  /**
   * Builds an instance of a model that includes either an automatically or manually created temporary ID, but does not add it to the store.
   * Does not support relationships, since they require references to objects in the store.
   * &#x60;&#x60;&#x60;
   * kpiHash = { name: &quot;A good thing to measure&quot; }
   * kpi = store.build(&#x27;kpis&#x27;, kpiHash)
   * kpi.name
   * =&gt; &quot;A good thing to measure&quot;
   * &#x60;&#x60;&#x60;
   * @method build
   * @param {String} type
   * @param {Object} properties the properties to use
   * @return {Object} the new record
   */
  build = (type, properties) =&gt; {
    const id = idOrNewId(properties.id)

    const attributes = this.pickAttributes(properties, type)
    const model = this.createModel(type, id, { attributes })

    return model
  }

  /**
   * @method addModel
   * @param {String} type
   * @param {Object} attributes json api attributes
   * @return {Object} Artemis Data record
   */
  @action
  addModel = (type, properties) =&gt; {
    const id = idOrNewId(properties.id)

    const attributes = this.pickAttributes(properties, type)
    const relationships = this.pickRelationships(properties, type)

    const model = this.createModel(type, id, { attributes, relationships })

    // Add the model to the type records index
    this.data[type].records.set(String(model.id), model)

    return model
  }

  /**
   * @method addModels
   * @param {String} type
   * @param {String} data array of data objects
   * @return {Array} array of ArtemisData records
   */
  addModels = (type, data) =&gt; {
    return runInAction(() =&gt; data.map((obj) =&gt; this.addModel(type, obj)))
  }

  /**
   * Saves a collection of records via a bulk-supported JSONApi
   * endpoint. All records need to be of the same type.
   *
   * @method bulkSave
   * @param {String} type
   * @param {Array} records
   * @param {Object} options {queryParams, extensions}
   */
  bulkSave = async (type, records, options = {}) =&gt; {
    const { queryParams, extensions } = options

    // get url for record type
    const url = this.fetchUrl(type, queryParams, null)

    // convert records to an appropriate jsonapi attribute/relationship format
    const recordAttributes = records.map((record) =&gt; record.jsonapi(options))

    // build a data payload
    const body = JSON.stringify({ data: recordAttributes })

    // build the json api extension string
    const extensionStr = extensions?.length
      ? &#x60;ext=&quot;bulk,${extensions.join()}&quot;&#x60;
      : &#x27;ext=&quot;bulk&quot;&#x27;

    // send request
    const response = this.fetch(url, {
      headers: {
        ...this.defaultFetchOptions.headers,
        &#x27;Content-Type&#x27;: &#x60;application/vnd.api+json; ${extensionStr}&#x60;
      },
      method: &#x27;POST&#x27;,
      body
    })

    // update records based on response
    return this.updateRecords(response, records)
  }

  /**
   * Adds a record from the store. We can&#x27;t simply remove the record
   * by deleting the records property/key via delete due to a bug
   * in mobx.
   *
   * @method remove
   * @param {String} type
   * @param {String} id of record to remove
   */
  @action
  remove = (type, id) =&gt; {
    this.data[type].records.delete(String(id))
  }

  /**
   * Gets a record from the store, will not fetch from the server if it doesn&#x27;t exist in store.
   * If given queryParams, it will check the cache for the record.
   *
   * @method getOne
   * @param {String} type the type to find
   * @param {String} id the id of the record to get
   * @param {Object} options { queryParams }
   * @return {Object} record
   */
  getOne = (type, id, options = {}) =&gt; {
    if (!id) {
      console.error(&#x60;No id given while calling &#x27;getOne&#x27; on ${type}&#x60;)
      return
    }
    const { queryParams } = options
    if (queryParams) {
      return this.getCachedRecord(type, id, queryParams)
    } else {
      return this.getRecord(type, id)
    }
  }

  /**
   * Fetches record by &#x60;id&#x60; from the server and returns a Promise.
   *
   * @async
   * @method fetchOne
   * @param {String} type the record type to fetch
   * @param {String} id the id of the record to fetch
   * @param {Object} options { queryParams }
   * @return {Object} record
   */
  async fetchOne (type, id, options = {}) {
    if (!id) {
      console.error(&#x60;No id given while calling &#x27;fetchOne&#x27; on ${type}&#x60;)
      return
    }
    const { queryParams } = options
    const url = this.fetchUrl(type, queryParams, id)

    const state = this.setLoadingState({ ...options, type, id, url })

    const response = await this.fetch(url, { method: &#x27;GET&#x27; })

    if (response.status === 200) {
      const json = await response.json()
      const { data, included } = json

      if (included) {
        this.createModelsFromData(included)
      }

      const record = this.createOrUpdateModel(data)

      this.data[type].cache.set(url, [record.id])
      this.deleteLoadingState(state)
      return record
    } else {
      // TODO: return Promise.reject(response.status)
      this.deleteLoadingState(state)
      return null
    }
  }

  /**
   * Finds a record by &#x60;id&#x60;.
   * If available in the store, it returns that record. Otherwise, it fetches the record from the server.
   *
   *   store.findOne(&#x27;todos&#x27;, 5)
   *   // fetch triggered
   *   =&gt; event1
   *   store.findOne(&#x27;todos&#x27;, 5)
   *   // no fetch triggered
   *   =&gt; event1
   *
   * @method findOne
   * @param {String} type the type to find
   * @param {String} id the id of the record to find
   * @param {Object} options { queryParams }
   * @return {Promise||Object} // TODO: make this always return a Promise
   */
  findOne = (type, id, options = {}) =&gt; {
    if (!id) {
      console.error(&#x60;No id given while calling &#x27;findOne&#x27; on ${type}&#x60;)
      return
    }
    const record = this.getOne(type, id, options)
    if (record?.id) {
      return record
    } else {
      return this.fetchOne(type, id, options)
    }
  }

  /**
   * Get all records with the given &#x60;type&#x60; and &#x60;ids&#x60; from the store. This will never fetch from the server.
   *
   * @method getMany
   * @param {String} type the type to get
   * @param {String} ids the ids of the records to get
   * @param {Object} options { queryParams }
   * @return {Array} array of records
   */
  getMany = (type, ids, options = {}) =&gt; {
    const idsToQuery = ids.slice().map(String)
    const records = this.getAll(type, options)

    return records.filter((record) =&gt; idsToQuery.includes(record.id))
  }

  /**
   * Fetch all records with the given &#x60;type&#x60; and &#x60;ids&#x60; from the server.
   *
   * @method fetchMany
   * @param {String} type the type to get
   * @param {String} ids the ids of the records to get
   * @param {Object} options { queryParams }
   * @return {Promise} Promise.resolve(records) or Promise.reject(status)
   */
  fetchMany = (type, ids, options = {}) =&gt; {
    const idsToQuery = ids.slice().map(String)
    const { queryParams = {}, queryTag } = options
    queryParams.filter = queryParams.filter || {}

    const baseUrl = this.fetchUrl(type, queryParams)
    const idQueries = deriveIdQueryStrings(idsToQuery, baseUrl)
    const queries = idQueries.map((queryIds) =&gt; {
      queryParams.filter.ids = queryIds
      return this.fetchAll(type, { queryParams, queryTag })
    })

    return Promise.all(queries)
      .then(records =&gt; [].concat(...records))
      .catch(err =&gt; Promise.reject(err))
  }

 /**
   * Finds multiple records of the given &#x60;type&#x60; with the given &#x60;ids&#x60; and returns them wrapped in a Promise.
   * If all records are in the store, it returns those.
   * If some records are in the store, it returns those plus fetches all other records.
   * Otherwise, it fetches all records from the server.
   *
   *   store.findMany(&#x27;todos&#x27;, [1, 2, 3])
   *   // fetch triggered
   *   =&gt; [todo1, todo2, todo3]
   *
   *   store.findMany(&#x27;todos&#x27;, [3, 2, 1])
   *   // no fetch triggered
   *   =&gt; [todo1, todo2, todo3]
   *
   * @method findMany
   * @param {String} type the type to find
   * @param {String} ids the ids of the records to find
   * @param {Object} options { queryParams }
   * @return {Promise||Object} // TODO: make this always return a Promise
   */
  findMany = (type, ids, options = {}) =&gt; {
    let idsToQuery = ids.slice().map(String)
    const recordsInStore = this.getAll(type, options).filter((record) =&gt;
      idsToQuery.includes(String(record.id))
    )

    if (recordsInStore.length === idsToQuery.length) {
      return recordsInStore
    }

    const recordIdsInStore = recordsInStore.map(({ id }) =&gt; String(id))
    idsToQuery = idsToQuery.filter((id) =&gt; !recordIdsInStore.includes(id))

    const { queryParams = {}, queryTag } = options
    queryParams.filter = queryParams.filter || {}
    const baseUrl = this.fetchUrl(type, queryParams)
    const idQueries = deriveIdQueryStrings(idsToQuery, baseUrl)

    const query = Promise.all(
      idQueries.map((queryIds) =&gt; {
        queryParams.filter.ids = queryIds
        return this.fetchAll(type, { queryParams, queryTag })
      })
    )

    return query.then((recordsFromServer) =&gt;
      recordsInStore.concat(...recordsFromServer)
    )
  }

  /**
   * Builds fetch url based
   *
   * @method fetchUrl
   * @param {String} type the type to find
   * @param {Object} options
   */
  fetchUrl (type, queryParams, id, options) {
    const { baseUrl, modelTypeIndex } = this
    const { endpoint } = modelTypeIndex[type]

    return requestUrl(baseUrl, endpoint, queryParams, id, options)
  }

  /**
   * Gets all records with the given &#x60;type&#x60; from the store. This will never fetch from the server.
   *
   * @method getAll
   * @param {String} type the type to find
   * @param {Object} options
   * @return {Array} array of records
   */
  getAll = (type, options = {}) =&gt; {
    const { queryParams } = options
    if (queryParams) {
      return this.getCachedRecords(type, queryParams)
    } else {
      return this.getRecords(type)
    }
  }

  /**
   * Sets a loading state when a fetch / deserialization is in flight. Loading states
   * are Sets inside of the &#x60;loadingStates&#x60; Map, so multiple loading states can be in flight
   * at the same time. An optional query tag can be passed to identify the particular query.
   *
   * const todos = store.fetchAll(&#x27;todos&#x27;, { queryTag: &#x27;myTodos&#x27; })
   * store.loadingStates.get(&#x27;myTodos&#x27;)
   * =&gt; Set([{ url, type, queryParams, queryTag }])
   *
   * @method setLoadingState
   * @param {Object} options options that can be used to build the loading state info
   * @return {Object} the loading state that was added
   */
  setLoadingState = ({ url, type, queryParams, queryTag }) =&gt; {
    queryTag = queryTag || type

    const loadingStateInfo = { url, type, queryParams, queryTag }

    let querySet = this.loadingStates.get(queryTag)
    if (!querySet) {
      querySet = observable.set([], { deep: false })
      this.loadingStates.set(queryTag, querySet)
    }
    querySet.add(loadingStateInfo)
    return loadingStateInfo
  }

  /**
   * Removes a loading state. If that leaves an empty array for the map key in &#x60;loadingStates&#x60;,
   * will also delete the set.
   * @method deleteLoadingState
   * @param {Object} state the state to remove
   */
  deleteLoadingState = (state) =&gt; {
    const querySet = this.loadingStates.get(state.queryTag)

    querySet.delete(state)
    if (querySet.size === 0) {
      this.loadingStates.delete(state.queryTag)
    }
  }

  /**
   * Finds all records with the given &#x60;type&#x60;. Always fetches from the server.
   *
   * @async
   * @method fetchAll
   * @param {String} type the type to find
   * @param {Object} options
   * @return {Promise} Promise.resolve(records) or Promise.reject(status)
   */
  fetchAll = async (type, options = {}) =&gt; {
    const { queryParams } = options

    const url = this.fetchUrl(type, queryParams)

    const state = this.setLoadingState({ ...options, type, url })

    const response = await this.fetch(url, { method: &#x27;GET&#x27; })

    if (response.status === 200) {
      this.data[type].cache.set(url, [])
      const json = await response.json()

      if (json.included) {
        this.createModelsFromData(json.included)
      }

      const records = runInAction(() =&gt;
        json.data.map((dataObject) =&gt; {
          const { id, attributes = {}, relationships = {} } = dataObject
          const record = this.createModel(type, id, { attributes, relationships })
          const cachedIds = this.data[type].cache.get(url)
          this.data[type].cache.set(url, [...cachedIds, id])
          this.data[type].records.set(String(id), record)
          return record
        })
      )
      this.deleteLoadingState(state)
      return records
    } else {
      this.deleteLoadingState(state)
      return Promise.reject(response.status)
    }
  }

  /**
   * Finds all records of the given &#x60;type&#x60;.
   * If all records are in the store, it returns those.
   * Otherwise, it fetches all records from the server.
   *
   *   store.findAll(&#x27;todos&#x27;)
   *   // fetch triggered
   *   =&gt; [todo1, todo2, todo3]
   *
   *   store.findAll(&#x27;todos&#x27;)
   *   // no fetch triggered
   *   =&gt; [todo1, todo2, todo3]
   *
   * Query params can be passed as part of the options hash.
   * The response will be cached, so the next time &#x60;findAll&#x60;
   * is called with identical params and values, the store will
   * first look for the local result.
   *
   *   store.findAll(&#x27;todos&#x27;, {
   *     queryParams: {
   *       filter: {
   *         start_time: &#x27;2020-06-01T00:00:00.000Z&#x27;,
   *         end_time: &#x27;2020-06-02T00:00:00.000Z&#x27;
   *       }
   *     }
   *   })
   *
   *
   * NOTE: A broader RFC is in development to improve how we keep data in sync
   * with the server. We likely will want to getAll and getRecords
   * to return null if nothing is found. However, this causes several regressions
   * in portal we will need to address in a larger PR for mobx-async-store updates.
   *
   * @method findAll
   * @param {String} type the type to find
   * @param {Object} options { queryParams }
   * @return {Promise} Promise.resolve(records) or Promise.reject(status)
   */
  findAll = (type, options = {}) =&gt; {
    const records = this.getAll(type, options)
    if (records.length &gt; 0) {
      return records
    } else {
      return this.fetchAll(type, options)
    }
  }

  /**
   * Clears the store of a given type, or clears all if no type given
   *
   *   store.reset(&#x27;todos&#x27;)
   *   // removes all todos from store
   *   store.reset()
   *   // clears store
   *
   * @method reset
   */
  reset (type) {
    if (type) {
      this.data[type] = {
        records: observable.map({}),
        cache: observable.map({})
      }
    } else {
      this.initializeObservableDataProperty()
    }
  }

  /* Private Methods */

  /**
   * Entry point for configuring the store
   *
   * @method init
   * @param {Object} options passed to constructor
   */
  init (options) {
    this.initializeNetworkConfiguration(options)
    this.initializeModelTypeIndex()
    this.initializeObservableDataProperty()
  }

  /**
   * Entry point for configuring the store
   *
   * @method initializeNetworkConfiguration
   * @param {Object} options for nextwork config
   */
  initializeNetworkConfiguration (options = {}) {
    this.baseUrl = options.baseUrl || &#x27;&#x27;
    this.defaultFetchOptions = options.defaultFetchOptions || {}
    this.headersOfInterest = options.headersOfInterest || []
  }

  /**
   * Entry point for configuring the store
   *
   * @method initializeNetworkConfiguration
   * @param {Object} options for nextwork config
   */
  initializeModelTypeIndex () {
    const { types } = this.constructor
    this.modelTypeIndex = types.reduce((modelTypeIndex, modelKlass) =&gt; {
      modelTypeIndex[modelKlass.type] = modelKlass
      return modelTypeIndex
    }, {})
  }

  /**
   * Creates an obserable index with model types
   * as the primary key
   *
   * Observable({ todos: {} })
   *
   * @method initializeObservableDataProperty
   */
  @action
  initializeObservableDataProperty () {
    const { types } = this.constructor

    // NOTE: Is there a performance cost to setting
    // each property individually?
    types.forEach((modelKlass) =&gt; {
      this.data[modelKlass.type] = {
        records: observable.map({}),
        cache: observable.map({})
      }
    })
  }

  /**
   * Wrapper around fetch applies user defined fetch options
   *
   * @method fetch
   * @param {String} url
   * @param {Object} options
   */
  fetch (url, options = {}) {
    const { defaultFetchOptions, headersOfInterest } = this
    const fetchOptions = { ...defaultFetchOptions, ...options }
    const key = JSON.stringify({ url, fetchOptions })

    return combineRacedRequests(key, () =&gt;
      fetch(url, { ...defaultFetchOptions, ...options })
    ).then(response =&gt; {
      // Capture headers of interest
      if (headersOfInterest) {
        runInAction(() =&gt; {
          headersOfInterest.forEach(header =&gt; {
            const value = response.headers.get(header)
            // Only set if it has changed, to minimize observable changes
            if (this.lastResponseHeaders[header] !== value) this.lastResponseHeaders[header] = value
          })
        })
      }

      return response
    })
  }

  /**
   * Gets type of collection from data observable
   *
   * @method getType
   * @param {String} type
   * @return {Object} observable type object structure
   */
  getType (type) {
    return this.data[type]
  }

  /**
   * Gets individual record from store
   *
   * @method getRecord
   * @param {String} type
   * @param {Number} id
   * @return {Object} record
   */
  getRecord (type, id) {
    if (!this.getType(type)) {
      throw new Error(&#x60;Could not find a collection for type &#x27;${type}&#x27;&#x60;)
    }

    const record = this.getType(type).records.get(String(id))

    if (!record || record === &#x27;undefined&#x27;) return

    return record
  }

  /**
   * Gets records for type of collection from observable
   *
   * NOTE: We only return records by unique id, this handles a scenario
   * where the store keeps around a reference to a newly persisted record by its temp uuid.
   * We can&#x27;t simply remove the temp uuid reference because other
   * related models may be still using the temp uuid in their relationships
   * data object. However, when we are listing out records we want them
   * to be unique by the persisted id (which is updated after a Model.save)
   *
   * @method getRecords
   * @param {String} type
   * @return {Array} array of objects
   */
  getRecords (type) {
    const records = Array.from(this.getType(type).records.values()).filter(
      (value) =&gt; value &amp;&amp; value !== &#x27;undefined&#x27;
    )
    return uniqBy(records, &#x27;id&#x27;)
  }

  /**
   * Get multiple records by id
   *
   * @method getRecordsById
   * @param {String} type
   * @param {Array} ids
   * @return {Array} array or records
   */
  getRecordsById (type, ids = []) {
    // NOTE: Is there a better way to do this?
    return ids
      .map((id) =&gt; this.getRecord(type, id))
      .filter((record) =&gt; record)
      .filter((record) =&gt; typeof record !== &#x27;undefined&#x27;)
  }

  /**
   * Gets single from store based on cached query
   *
   * @method getCachedRecord
   * @param {String} type
   * @param id
   * @param {Object} queryParams
   * @return {Object} record
   */
  getCachedRecord (type, id, queryParams) {
    const cachedRecords = this.getCachedRecords(type, queryParams, id)

    return cachedRecords &amp;&amp; cachedRecords[0]
  }

  /**
   * Gets records from store based on cached query
   *
   * @method getCachedRecords
   * @param {String} type type of records to get
   * @param {Object} queryParams
   * @param {String} id optional param if only getting 1 cached record by id
   * @return {Array} array of records
   */
  getCachedRecords (type, queryParams, id) {
    // Get the url the request would use
    const url = this.fetchUrl(type, queryParams, id)
    // Get the matching ids from the response
    const ids = this.getCachedIds(type, url)
    // Get the records matching the ids
    return this.getRecordsById(type, ids)
  }

  /**
   * Gets records from store based on cached query
   *
   * @method getCachedIds
   * @param {String} type
   * @param {String} url
   * @return {Array} array of ids
   */
  getCachedIds (type, url) {
    const ids = this.getType(type).cache.get(url)
    if (!ids) return []
    const idsSet = new Set(toJS(ids))
    return Array.from(idsSet)
  }

  /**
   * Gets records from store based on cached query
   *
   * @method getCachedId
   * @param {String} type
   * @param {String} url
   * @return {Array} array of ids
   */
  getCachedId (type, id) {
    return this.getType(type).cache.get(String(id))
  }

  /**
   * Helper to look up model class for type.
   *
   * @method getKlass
   * @param {String} type
   * @return {Class} model class
   */
  getKlass (type) {
    return this.modelTypeIndex[type]
  }

  /**
   * Creates or updates a model
   *
   * @method createOrUpdateModel
   * @param {Object} dataObject
   */
  createOrUpdateModel (dataObject) {
    const { attributes = {}, id, relationships = {}, type } = dataObject

    let record = this.getRecord(type, id)

    if (record) {
      // Update existing object attributes
      Object.keys(attributes).forEach((key) =&gt; {
        set(record, key, attributes[key])
      })

      // If relationships are present, update relationships
      // TODO: relationships will always be truthy since we&#x27;ve defined a default above.
      if (relationships) {
        Object.keys(relationships).forEach((key) =&gt; {
          // Don&#x27;t try to create relationship if meta included false
          if (!relationships[key].meta) {
            // defensive against existingRecord.relationships being undefined
            set(record, &#x27;relationships&#x27;, {
              ...record.relationships,
              [key]: relationships[key]
            })
          }
        })
      }
      record._takeSnapshot({ persisted: true })
    } else {
      record = this.createModel(type, id, { attributes, relationships })
    }

    this.data[type].records.set(String(record.id), record)
    return record
  }

  /**
   * Create multiple models from an array of data
   *
   * @method createModelsFromData
   * @param {Array} data
   */
  createModelsFromData (data) {
    return runInAction(() =&gt;
      data.map((dataObject) =&gt; {
        // Only build objects for which we have a type defined.
        // And ignore silently anything else included in the JSON response.
        // TODO: Put some console message in development mode
        if (this.getType(dataObject.type)) {
          return this.createOrUpdateModel(dataObject)
        } else {
          console.warn(&#x60;no type defined for ${dataObject.type}&#x60;)
          return null
        }
      })
    )
  }

  /**
   * Helper to create a new model
   *
   * @method createModel
   * @param {String} type
   * @param {Number} type
   * @param {Object} attributes
   * @return {Object} model instance
   */
  createModel (type, id, data) {
    const { attributes = {}, relationships = {} } = toJS(data)
    const store = this
    const ModelKlass = this.getKlass(type)

    if (!ModelKlass) {
      throw new Error(&#x60;Could not find a model for &#x27;${type}&#x27;&#x60;)
    }

    return new ModelKlass({ id, store, relationships, ...attributes })
  }

  /**
   * Defines a resolution for an API call that will update a record or
   * set of records with the data returned from the API
   *
   * @method updateRecords
   * @param {Promise} a request to the API
   * @param {Model|Array} records to be updated
   */
  updateRecords (promise, records) {
    // records may be a single record, if so wrap it in an array to make
    // iteration simpler
    const recordsArray = Array.isArray(records) ? records : [records]
    recordsArray.forEach((record) =&gt; {
      record.isInFlight = true
    })

    return promise.then(
      async (response) =&gt; {
        const { status } = response

        recordsArray.forEach((record) =&gt; {
          record.isInFlight = false
        })

        if (status === 200 || status === 201) {
          const json = await response.json()
          const data = Array.isArray(json.data) ? json.data : [json.data]
          const { included } = json

          if (data.length !== recordsArray.length) {
            throw new Error(
              &#x27;Invariant violated: API response data and records to update do not match&#x27;
            )
          }

          data.forEach((targetData, index) =&gt; {
            recordsArray[index].updateAttributesFromResponse(
              targetData,
              included
            )
          })

          if (json.included) {
            this.createModelsFromData(json.included)
          }

          // on success, return the original record(s).
          // again - this may be a single record so preserve the structure
          return records
        } else {
          let json = {}
          try {
            json = await response.json()
          } catch (error) {
            // 500 doesn&#x27;t return a parsable response
            return Promise.reject(new Error(this.genericErrorMessage))
          }

          if (!json.errors) {
            return Promise.reject(new Error(this.genericErrorMessage))
          }

          if (!Array.isArray(json.errors)) {
            return Promise.reject(new TypeError(&#x27;Top level errors in response are not an array.&#x27;))
          }

          // Add all errors from the API response to the record(s).
          // This is done by comparing the pointer in the error to
          // the request.
          let errorString
          runInAction(() =&gt; {
            json.errors.forEach((error) =&gt; {
              const { index, key } = parseErrorPointer(error)
              if (key != null) {
                const errors = recordsArray[index].errors[key] || []
                errors.push(error)
                recordsArray[index].errors[key] = errors
              }
            })
            errorString = recordsArray
              .map((record) =&gt; JSON.stringify(record.errors))
              .join(&#x27;;&#x27;)
          })

          return Promise.reject(new Error(errorString))
        }
      },
      function (error) {
        // TODO: Handle error states correctly, including handling errors for multiple targets
        recordsArray.forEach((record) =&gt; {
          record.isInFlight = false
        })
        recordsArray[0].errors = error
        throw error
      }
    )
  }
}

export default Store

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
