<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: Store.ts</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="",baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body class="dark" data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="7NRo_-Jm7KqI4isjHcwEl"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="FactoryFarm.html">FactoryFarm</a></div><div class="sidebar-section-children"><a href="FactoryFarm.html">FactoryFarm</a></div><div class="sidebar-section-children"><a href="MockServer.html">MockServer</a></div><div class="sidebar-section-children"><a href="Model.html">Model</a></div><div class="sidebar-section-children"><a href="RelatedRecordsArray.html">RelatedRecordsArray</a></div><div class="sidebar-section-children"><a href="Store.html">Store</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="b4BbqHmDKrCMB8mrPy_yj"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#QueryString">QueryString</a></div><div class="sidebar-section-children"><a href="global.html#addIncluded">addIncluded</a></div><div class="sidebar-section-children"><a href="global.html#addRelatedRecord">addRelatedRecord</a></div><div class="sidebar-section-children"><a href="global.html#arrayType">arrayType</a></div><div class="sidebar-section-children"><a href="global.html#circularFetchError">circularFetchError</a></div><div class="sidebar-section-children"><a href="global.html#circularFindError">circularFindError</a></div><div class="sidebar-section-children"><a href="global.html#coerceDataToExistingRecord">coerceDataToExistingRecord</a></div><div class="sidebar-section-children"><a href="global.html#combineRacedRequests">combineRacedRequests</a></div><div class="sidebar-section-children"><a href="global.html#dateType">dateType</a></div><div class="sidebar-section-children"><a href="global.html#decrementor">decrementor</a></div><div class="sidebar-section-children"><a href="global.html#defineToManyRelationships">defineToManyRelationships</a></div><div class="sidebar-section-children"><a href="global.html#defineToOneRelationships">defineToOneRelationships</a></div><div class="sidebar-section-children"><a href="global.html#definitionsByDirection">definitionsByDirection</a></div><div class="sidebar-section-children"><a href="global.html#deriveIdQueryStrings">deriveIdQueryStrings</a></div><div class="sidebar-section-children"><a href="global.html#diff">diff</a></div><div class="sidebar-section-children"><a href="global.html#disallowFetches">disallowFetches</a></div><div class="sidebar-section-children"><a href="global.html#fetchWithRetry">fetchWithRetry</a></div><div class="sidebar-section-children"><a href="global.html#getOneFromFactory">getOneFromFactory</a></div><div class="sidebar-section-children"><a href="global.html#incrementor">incrementor</a></div><div class="sidebar-section-children"><a href="global.html#isEmptyString">isEmptyString</a></div><div class="sidebar-section-children"><a href="global.html#isValid">isValid</a></div><div class="sidebar-section-children"><a href="global.html#makeDate">makeDate</a></div><div class="sidebar-section-children"><a href="global.html#mobxAnnotations">mobxAnnotations</a></div><div class="sidebar-section-children"><a href="global.html#mobxAnnotations">mobxAnnotations</a></div><div class="sidebar-section-children"><a href="global.html#newId">newId</a></div><div class="sidebar-section-children"><a href="global.html#numberType">numberType</a></div><div class="sidebar-section-children"><a href="global.html#objectType">objectType</a></div><div class="sidebar-section-children"><a href="global.html#parseErrorPointer">parseErrorPointer</a></div><div class="sidebar-section-children"><a href="global.html#parseErrors">parseErrors</a></div><div class="sidebar-section-children"><a href="global.html#removeRelatedRecord">removeRelatedRecord</a></div><div class="sidebar-section-children"><a href="global.html#requestUrl">requestUrl</a></div><div class="sidebar-section-children"><a href="global.html#serverResponse">serverResponse</a></div><div class="sidebar-section-children"><a href="global.html#setRelatedRecord">setRelatedRecord</a></div><div class="sidebar-section-children"><a href="global.html#simulatePatch">simulatePatch</a></div><div class="sidebar-section-children"><a href="global.html#simulatePost">simulatePost</a></div><div class="sidebar-section-children"><a href="global.html#stringType">stringType</a></div><div class="sidebar-section-children"><a href="global.html#stringifyIds">stringifyIds</a></div><div class="sidebar-section-children"><a href="global.html#toFullJsonapi">toFullJsonapi</a></div><div class="sidebar-section-children"><a href="global.html#validatePresence">validatePresence</a></div><div class="sidebar-section-children"><a href="global.html#validateProperties">validateProperties</a></div><div class="sidebar-section-children"><a href="global.html#validatesArray">validatesArray</a></div><div class="sidebar-section-children"><a href="global.html#validatesArrayPresence">validatesArrayPresence</a></div><div class="sidebar-section-children"><a href="global.html#validatesOptions">validatesOptions</a></div><div class="sidebar-section-children"><a href="global.html#validatesString">validatesString</a></div><div class="sidebar-section-children"><a href="global.html#walk">walk</a></div><div class="sidebar-section-children"><a href="global.html#wrapResponse">wrapResponse</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">Store.ts</h1></header><article><pre class="prettyprint source lang-js"><code>import { action, makeObservable, observable, runInAction, toJS } from 'mobx'
import pick from 'lodash/pick'
import {
  fetchWithRetry,
  deriveIdQueryStrings,
  parseErrors,
  parseErrorPointer,
  requestUrl,
  newId
} from './utils'
import cloneDeep from 'lodash/cloneDeep'

/**
 * Annotations for mobx observability. We can't use `makeAutoObservable` because we have subclasses.
 */

const mobxAnnotations = {
  data: observable,
  lastResponseHeaders: observable,
  loadingStates: observable,
  loadedStates: observable,
  add: action,
  pickAttributes: action,
  pickRelationships: action,
  bulkSave: action,
  _bulkSave: action,
  bulkCreate: action,
  bulkUpdate: action,
  remove: action,
  getOne: action,
  fetchOne: action,
  findOne: action,
  getMany: action,
  fetchMany: action,
  findMany: action,
  fetchUrl: action,
  getAll: action,
  setLoadingState: action,
  deleteLoadingState: action,
  fetchAll: action,
  findAll: action,
  reset: action,
  init: action,
  initializeNetworkConfiguration: action,
  initializeModelIndex: action,
  initializeErrorMessages: action,
  fetch: action,
  getRecord: action,
  getRecords: action,
  getRecordsById: action,
  clearCache: action,
  getCachedRecord: action,
  getCachedRecords: action,
  getCachedIds: action,
  getCachedId: action,
  getKlass: action,
  createOrUpdateModelFromData: action,
  updateRecordFromData: action,
  createOrUpdateModelsFromData: action,
  createModelFromData: action,
  updateRecordsFromResponse: action
}

/**
 * Defines the Data Store class.
 */
class Store {
  /**
   * Stores data by type.
   * {
   *   todos: {
   *     records: observable.map(), // records by id
   *     cache: observable.map(), // cached ids by url
   *     meta: observable.map() // meta information by url
   *   }
   * }
   *
   * @type {object}
   * @default {}
   */
  data = {}

  /**
   * The most recent response headers according to settings specified as `headersOfInterest`
   *
   * @type {object}
   * @default {}
   */
  lastResponseHeaders = {}

  /**
   * Map of data that is in flight. This can be observed to know if a given type (or tag)
   * is still processing.
   * - Key is a tag that is either the model type or a custom value
   * - Falue is a Set of JSON-encoded objects with unique urls and queryParams
   *   Set[JSON.stringify({ url, type, queryParams, queryTag })]
   *
   * @type {Map}
   */
  loadingStates = new Map()

  /**
   * Map of data that has been loaded into the store. This can be observed to know if a given
   * type (or tag) has finished loading.
   * - Key is a tag that is either the model type or a custom value
   * - Falue is a Set of JSON-encoded objects with unique urls and queryParams
   *   Set[JSON.stringify({ url, type, queryParams, queryTag })]
   *
   * @type {Map}
   */

  loadedStates = new Map()

  /**
   * True if models in the store should stop taking snapshots. This is
   * useful when updating records without causing records to become
   * 'dirty', for example when initializing records using `add`
   *
   * @type {boolean}
   */
  pauseSnapshots = false

  /**
   * Initializer for Store class
   *
   * @param {object} options options to use for initialization
   */
  constructor (options) {
    makeObservable(this, mobxAnnotations)
    this.init(options)
  }

  /**
   * Adds an instance or an array of instances to the store.
   * Adds the model to the type records index
   * Adds relationships explicitly. This is less efficient than adding via data if
   * there are also inverse relationships.
   *
   * ```
   * const todo = store.add('todos', { name: "A good thing to measure" })
   * todo.name
   * => "A good thing to measure"
   *
   * const todoArray = [{ name: "Another good thing to measure" }]
   * const [todo] = store.add('todos', [{ name: "Another good thing to measure" }])
   * todo.name
   * => "Another good thing to measure"
   * ```
   *
   * @param {string} type the model type
   * @param {object|Array} props the properties to use
   * @param {object} options currently supports `skipInitialization`
   * @returns {object|Array} the new record or records
   */
  add (type, props = {}, options) {
    if (props.constructor.name === 'Array') {
      return props.map((model) => this.add(type, model))
    } else {
      const id = String(props.id || newId())

      const attributes = cloneDeep(this.pickAttributes(props, type))

      const record = this.createModelFromData({ type, id, attributes }, options)

      // set separately to get inverses
      this.pauseSnapshots = true
      Object.entries(this.pickRelationships(props, type)).forEach(([key, value]) => {
        record[key] = value
      })
      this.pauseSnapshots = false

      this.data[type].records.set(id, record)

      return record
    }
  }

  /**
   * Given a set of properties and type, returns an object with only the properties
   * that are defined as attributes in the model for that type.
   * ```
   * properties = { title: 'Do laundry', unrelatedProperty: 'Do nothing' }
   * pickAttributes(properties, 'todos')
   * => { title: 'Do laundry' }
   * ```
   *
   * @param {object} properties a full list of properties that may or may not conform
   * @param {string} type the model type
   * @returns {object} the scrubbed attributes
   */
  pickAttributes (properties, type) {
    const attributeNames = Object.keys(this.getKlass(type).attributeDefinitions)
    return pick(properties, attributeNames)
  }

  /**
   * Given a set of properties and type, returns an object with only the properties
   * that are defined as relationships in the model for that type.
   * ```
   * properties = { notes: [note1, note2], category: cat1, title: 'Fold Laundry' }
   * pickRelationships(properties, 'todos')
   * => {
   *       notes: {
   *         data: [{ id: '1', type: 'notes' }, { id: '2', type: 'notes' }]
   *       },
   *       category: {
   *         data: { id: '1', type: 'categories' }
   *       }
   *    }
   * ```
   *
   * @param {object} properties a full list of properties that may or may not conform
   * @param {string} type the model type
   * @returns {object} the scrubbed relationships
   */
  pickRelationships (properties, type) {
    const definitions = this.getKlass(type).relationshipDefinitions
    return definitions ? pick(properties, Object.keys(definitions)) : {}
  }

  /**
   * Saves a collection of records via a bulk-supported JSONApi endpoint.
   * All records need to be of the same type.
   *
   * @param {string} type the model type
   * @param {Array} records records that will be bulk saved
   * @param {object} options {queryParams, extensions}
   * @returns {Promise} the saved records
   */
  bulkSave (type, records, options = {}) {
    console.warn('bulkSave is deprecated. Please use either bulkCreate or bulkUpdate to be more precise about your request.')
    return this._bulkSave(type, records, options, 'POST')
  }

  /**
   * Saves a collection of records via a bulk-supported JSONApi endpoint.
   * All records need to be of the same type.
   * - gets url for record type
   * - converts records to an appropriate jsonapi attribute/relationship format
   * - builds a data payload
   * - builds the json api extension string
   * - sends request
   * - update records based on response
   *
   * @private
   * @param {string} type the model type
   * @param {Array} records records to be bulk saved
   * @param {object} options {queryParams, extensions}
   * @param {string} method http method
   * @returns {Promise} the saved records
   */
  _bulkSave (type, records, options = {}, method) {
    const { queryParams, extensions } = options

    const url = this.fetchUrl(type, queryParams, null)
    const recordAttributes = records.map((record) => record.jsonapi(options))
    const body = JSON.stringify({ data: recordAttributes })

    const extensionStr = extensions?.length
      ? `ext="bulk,${extensions.join()}"`
      : 'ext="bulk"'

    const response = this.fetch(url, {
      headers: {
        ...this.defaultFetchOptions.headers,
        'Content-Type': `application/vnd.api+json; ${extensionStr}`
      },
      method,
      body
    })

    return this.updateRecordsFromResponse(response, records)
  }

  /**
   * Save a collection of new records via a bulk-supported JSONApi endpoint.
   * All records need to be of the same type and not have an existing id.
   *
   * @param {string} type the model type
   * @param {Array} records to be bulk created
   * @param {object} options {queryParams, extensions}
   * @returns {Promise} the created records
   */
  bulkCreate (type, records, options = {}) {
    if (records.some((record) => !record.isNew)) {
      throw new Error('Invariant violated: all records must be new records to perform a create')
    }
    return this._bulkSave(type, records, options, 'POST')
  }

  /**
   * Updates a collection of records via a bulk-supported JSONApi endpoint.
   * All records need to be of the same type and have an existing id.
   *
   * @param {string} type the model type
   * @param {Array} records array of records to be bulk updated
   * @param {object} options {queryParams, extensions}
   * @returns {Promise} the saved records
   */
  bulkUpdate (type, records, options = {}) {
    if (records.some((record) => record.isNew)) {
      throw new Error('Invariant violated: all records must have a persisted id to perform an update')
    }
    return this._bulkSave(type, records, options, 'PATCH')
  }

  /**
   * Removes a record from the store by deleting it from the
   * type's record map
   *
   * @param {string} type the model type
   * @param {string} id of record to remove
   */
  remove (type, id) {
    this.data[type].records.delete(String(id))
  }

  /**
   * Gets a record from the store. Will never fetch from the server.
   * If given queryParams, it will check the cache for the record.
   *
   * @param {string} type the type to find
   * @param {string} id the id of the record to get
   * @param {object} options { queryParams }
   * @returns {object} record
   */
  getOne (type, id, options = {}) {
    if (!id) {
      console.error(`No id given while calling 'getOne' on ${type}`)
      return undefined
    }
    const { queryParams } = options
    if (queryParams) {
      return this.getCachedRecord(type, id, queryParams)
    } else {
      return this.getRecord(type, id)
    }
  }

  /**
   * Fetches record by `id` from the server and returns a Promise.
   *
   * @async
   * @param {string} type the record type to fetch
   * @param {string} id the id of the record to fetch
   * @param {object} options { queryParams }
   * @returns {Promise} record result wrapped in a Promise
   */
  async fetchOne (type, id, options = {}) {
    if (!id) {
      console.error(`No id given while calling 'fetchOne' on ${type}`)
      return undefined
    }
    const { queryParams } = options
    const url = this.fetchUrl(type, queryParams, id)

    const state = this.setLoadingState({ ...options, type, id, url })

    const response = await this.fetch(url, { method: 'GET' })

    if (response.status === 200) {
      const { data, included } = await response.json()

      const record = this.createOrUpdateModelFromData(data)

      if (included) {
        this.createOrUpdateModelsFromData(included)
      }

      this.data[type].cache.set(url, [record.id])

      this.deleteLoadingState(state)
      return record
    } else {
      this.deleteLoadingState(state)
      const errors = await parseErrors(response, this.errorMessages)
      throw new Error(JSON.stringify(errors))
    }
  }

  /**
   * Finds a record by `id`, always returning a Promise.
   * If available in the store, it returns that record. Otherwise, it fetches the record from the server.
   *
   *   store.findOne('todos', 5)
   *   // fetch triggered
   *   => Promise(todo)
   *   store.findOne('todos', 5)
   *   // no fetch triggered
   *   => Promise(todo)
   *
   * @param {string} type the type to find
   * @param {string} id the id of the record to find
   * @param {object} options { queryParams }
   * @returns {Promise} a promise that will resolve to the record
   */
  findOne (type, id, options = {}) {
    if (!id) {
      console.error(`No id given while calling 'findOne' on ${type}`)
      return undefined
    }
    const record = this.getOne(type, id, options)
    return record?.id ? record : this.fetchOne(type, id, options)
  }

  /**
   * Get all records with the given `type` and `ids` from the store. This will never fetch from the server.
   *
   * @param {string} type the type to get
   * @param {string} ids the ids of the records to get
   * @param {object} options { queryParams }
   * @returns {Array} array of records
   */
  getMany (type, ids, options = {}) {
    const idsToQuery = ids.slice().map(String)
    const records = this.getAll(type, options)

    return records.filter((record) => idsToQuery.includes(record.id))
  }

  /**
   * Fetch all records with the given `type` and `ids` from the server.
   *
   * @param {string} type the type to get
   * @param {string} ids the ids of the records to get
   * @param {object} options { queryParams }
   * @returns {Promise} Promise.resolve(records) or Promise.reject([Error: [{ detail, status }])
   */
  fetchMany (type, ids, options = {}) {
    const idsToQuery = ids.slice().map(String)
    const { queryParams = {}, queryTag } = options
    queryParams.filter = queryParams.filter || {}

    const baseUrl = this.fetchUrl(type, queryParams)
    const idQueries = deriveIdQueryStrings(idsToQuery, baseUrl)
    const queries = idQueries.map((queryIds) => {
      const params = cloneDeep(queryParams)
      params.filter.ids = queryIds

      return this.fetchAll(type, { queryParams: params, queryTag })
    })

    return Promise.all(queries)
      .then(records => [].concat(...records))
      .catch(err => Promise.reject(err))
  }

 /**
  * Finds multiple records of the given `type` with the given `ids` and returns them wrapped in a Promise.
  * If all records are in the store, it returns those.
  * If some records are in the store, it returns those plus fetches all other records.
  * Otherwise, it fetches all records from the server.
  *
  *   store.findMany('todos', [1, 2, 3])
  *   // fetch triggered
  *   => [todo1, todo2, todo3]
  *
  *   store.findMany('todos', [3, 2, 1])
  *   // no fetch triggered
  *   => [todo1, todo2, todo3]
  *
  * @param {string} type the type to find
  * @param {string} ids the ids of the records to find
  * @param {object} options { queryParams }
  * @returns {Promise} a promise that will resolve an array of records
  */
  async findMany (type, ids, options = {}) {
    ids = [...new Set(ids)].map(String)
    const existingRecords = this.getMany(type, ids, options)

    if (ids.length === existingRecords.length) {
      return existingRecords
    }

    const existingIds = existingRecords.map(({ id }) => id)
    const idsToQuery = ids.filter((id) => !existingIds.includes(id))

    const { queryParams = {}, queryTag } = options
    queryParams.filter = queryParams.filter || {}
    const baseUrl = this.fetchUrl(type, queryParams)
    const idQueries = deriveIdQueryStrings(idsToQuery, baseUrl)

    await Promise.all(
      idQueries.map((queryIds) => {
        queryParams.filter.ids = queryIds
        return this.fetchAll(type, { queryParams, queryTag })
      })
    )

    return this.getMany(type, ids)
  }

  /**
   * Builds fetch url based on type, queryParams, id, and options
   *
   * @param {string} type the type to find
   * @param {object} queryParams params to be used in the fetch
   * @param {string} id a model id
   * @param {object} options options for fetching
   * @returns {string} a formatted url
   */
  fetchUrl (type, queryParams, id, options) {
    const { baseUrl } = this
    const { endpoint } = this.getKlass(type)

    return requestUrl(baseUrl, endpoint, queryParams, id, options)
  }

  /**
   * Gets all records with the given `type` from the store. This will never fetch from the server.
   *
   * @param {string} type the type to find
   * @param {object} options options for fetching queryParams
   * @returns {Array} array of records
   */
  getAll (type, options = {}) {
    const { queryParams } = options
    if (queryParams) {
      return this.getCachedRecords(type, queryParams)
    } else {
      return this.getRecords(type).filter((record) => record.initialized)
    }
  }

  /**
   * Sets a loading state when a fetch / deserialization is in flight. Loading states
   * are Sets inside of the `loadingStates` Map, so multiple loading states can be in flight
   * at the same time. An optional query tag can be passed to identify the particular query.
   *
   * const todos = store.fetchAll('todos', { queryTag: 'myTodos' })
   * store.loadingStates.get('myTodos')
   * => Set([JSON.stringify({ url, type, queryParams, queryTag })])
   *
   * @param {object} options options that can be used to build the loading state info
   * @param {string} options.url the url queried
   * @param {string} options.type the model type
   * @param {string} options.queryParams the query params used
   * @param {string} options.queryTag an optional tag to use in place of the type
   * @returns {object} the loading state that was added
   */
  setLoadingState ({ url, type, queryParams, queryTag }) {
    queryTag = queryTag || type

    const loadingStateInfo = { url, type, queryParams, queryTag }

    if (!this.loadingStates.get(queryTag)) {
      this.loadingStates.set(queryTag, new Set())
    }
    this.loadingStates.get(queryTag).add(JSON.stringify(loadingStateInfo))

    return loadingStateInfo
  }

  /**
   * Removes a loading state. If that leaves an empty array for the map key in `loadingStates`,
   * will also delete the set. Also adds to loadedStates.
   *
   * @param {object} state the state to remove
   */
  deleteLoadingState (state) {
    const { loadingStates, loadedStates } = this
    const { queryTag } = state

    const encodedState = JSON.stringify(state)

    if (!loadedStates.get(queryTag)) {
      loadedStates.set(queryTag, new Set())
    }

    loadedStates.get(queryTag).add(encodedState)

    if (loadingStates.get(queryTag)) {
      loadingStates.get(queryTag).delete(encodedState)
      if (loadingStates.get(queryTag).size === 0) {
        loadingStates.delete(queryTag)
      }
    } else {
      console.warn(`no loadingState found for ${encodedState}`)
    }
  }

  /**
   * Finds all records with the given `type`. Always fetches from the server.
   *
   * @async
   * @param {string} type the type to find
   * @param {object} options query params and other options
   * @returns {Promise} Promise.resolve(records) or Promise.reject([Error: [{ detail, status }])
   */
  async fetchAll (type, options = {}) {
    const { queryParams } = options

    const url = this.fetchUrl(type, queryParams)

    const state = this.setLoadingState({ ...options, type, url })

    const response = await this.fetch(url, { method: 'GET' })

    if (response.status === 200) {
      const { included, data, meta } = await response.json()

      let records
      runInAction(() => {
        if (included) {
          this.createOrUpdateModelsFromData(included)
        }

        records = this.createOrUpdateModelsFromData(data)
        const recordIds = records.map(({ id }) => id)
        this.data[type].cache.set(url, recordIds)

        this.deleteLoadingState(state)
      })
      if (meta) {
        records.meta = meta
        this.data[type].meta.set(url, meta)
      }
      return records
    } else {
      runInAction(() => {
        this.deleteLoadingState(state)
      })
      const errors = await parseErrors(response, this.errorMessages)
      throw new Error(JSON.stringify(errors))
    }
  }

  /**
   * Finds all records of the given `type`.
   * If any records from the given type from url are in the store, it returns those.
   * Otherwise, it fetches all records from the server.
   *
   *   store.findAll('todos')
   *   // fetch triggered
   *   => [todo1, todo2, todo3]
   *
   *   store.findAll('todos')
   *   // no fetch triggered
   *   => [todo1, todo2, todo3]
   *
   * Query params can be passed as part of the options hash.
   * The response will be cached, so the next time `findAll`
   * is called with identical params and values, the store will
   * first look for the local result.
   *
   *   store.findAll('todos', {
   *     queryParams: {
   *       filter: {
   *         start_time: '2020-06-01T00:00:00.000Z',
   *         end_time: '2020-06-02T00:00:00.000Z'
   *       }
   *     }
   *   })
   *
   * @param {string} type the type to find
   * @param {object} options { queryParams }
   * @returns {Promise} Promise.resolve(records) or Promise.reject([Error: [{ detail, status }])
   */
  findAll (type, options) {
    const records = this.getAll(type, options)

    if (records?.length > 0) {
      return Promise.resolve(records)
    } else {
      return this.fetchAll(type, options)
    }
  }

  /**
   * Clears the store of a given type, or clears all if no type given
   *
   *   store.reset('todos')
   *   // removes all todos from store
   *   store.reset()
   *   // clears store
   *
   * @param {string} type the model type
   */
  reset (type) {
    const types = type ? [type] : this.models.map(({ type }) => type)
    types.forEach((type) => {
      this.data[type] = {
        records: observable.map(),
        cache: observable.map(),
        meta: observable.map()
      }
    })
  }

  /**
   * Entry point for configuring the store
   *
   * @param {object} options passed to constructor
   */
  init (options = {}) {
    this.initializeNetworkConfiguration(options)
    this.initializeModelIndex(options.models)
    this.reset()
    this.initializeErrorMessages(options)
  }

  /**
   * Configures the store's network options
   *
   * @param {string} options the parameters that will be used to set up network requests
   * @param {string} options.baseUrl the API's root url
   * @param {object} options.defaultFetchOptions options that will be used when fetching
   * @param {Array} options.headersOfInterest an array of headers to watch
   * @param {object} options.retryOptions options for re-fetch attempts and interval
   */
  initializeNetworkConfiguration ({ baseUrl = '', defaultFetchOptions = {}, headersOfInterest = [], retryOptions = { attempts: 1, delay: 0 } }) {
    this.baseUrl = baseUrl
    this.defaultFetchOptions = defaultFetchOptions
    this.headersOfInterest = headersOfInterest
    this.retryOptions = retryOptions
  }

  /**
   * Creates the key/value index of model types
   *
   * @param {object} models a fallback list of models
   */
  initializeModelIndex (models) {
    this.models = this.constructor.models || models
  }

  /**
   * Configure the error messages returned from the store when API requests fail
   *
   * @param {object} options for initializing the store
   *   options for initializing error messages for different HTTP status codes
   */
  initializeErrorMessages (options = {}) {
    const errorMessages = { ...options.errorMessages }

    this.errorMessages = {
      default: 'Something went wrong.',
      ...errorMessages
    }
  }

  /**
   * Wrapper around fetch applies user defined fetch options
   *
   * @param {string} url the url to fetch
   * @param {object} options override options to use for fetching
   * @returns {Promise} the data from the server
   */
  async fetch (url, options = {}) {
    const { defaultFetchOptions, headersOfInterest, retryOptions } = this
    const fetchOptions = { ...defaultFetchOptions, ...options }
    const { attempts, delay } = retryOptions

    const response = await fetchWithRetry(url, fetchOptions, attempts, delay)

    if (headersOfInterest) {
      runInAction(() => {
        headersOfInterest.forEach(header => {
          const value = response.headers.get(header)
          // Only set if it has changed, to minimize observable changes
          if (this.lastResponseHeaders[header] !== value) this.lastResponseHeaders[header] = value
        })
      })
    }

    return response
  }

  /**
   * Gets individual record from store
   *
   * @param {string} type the model type
   * @param {number} id the model id
   * @returns {object} record
   */
  getRecord (type, id) {
    if (!this.data[type]) {
      throw new Error(`Could not find a collection for type '${type}'`)
    }

    const record = this.data[type].records.get(String(id))

    return (!record || record === 'undefined') ? undefined : record
  }

  /**
   * Gets records for type of collection
   *
   * @param {string} type the model type
   * @returns {Array} array of objects
   */
  getRecords (type) {
    return Array.from(this.data[type].records.values())
  }

  /**
   * Get multiple records by id
   *
   * @param {string} type the model type
   * @param {Array} ids the ids to find
   * @returns {Array} array or records
   */
  getRecordsById (type, ids = []) {
    // NOTE: Is there a better way to do this?
    return ids
      .map((id) => this.getRecord(type, id))
      .filter((record) => record)
      .filter((record) => typeof record !== 'undefined')
  }

  /**
   * Clears the cache for provided record type
   *
   * @param {string} type the model type
   * @returns {Set} the cleared set
   */
  clearCache (type) {
    return this.data[type].cache.clear()
  }

  /**
   * Gets single from store based on cached query
   *
   * @param {string} type the model type
   * @param {string} id the model id
   * @param {object} queryParams the params to be searched
   * @returns {object} record
   */
  getCachedRecord (type, id, queryParams) {
    const cachedRecords = this.getCachedRecords(type, queryParams, id)

    return cachedRecords &amp;&amp; cachedRecords[0]
  }

  /**
   * Gets records from store based on cached query and any previously requested ids
   *
   * @param {string} type type of records to get
   * @param {object} queryParams query params that were used for the query
   * @param {string} id optional param if only getting 1 cached record by id
   * @returns {Array} array of records
   */
  getCachedRecords (type, queryParams, id) {
    const url = this.fetchUrl(type, queryParams, id)
    const ids = this.getCachedIds(type, url)
    const meta = this.data[type].meta.get(url)

    const cachedRecords = this.getRecordsById(type, ids)

    if (meta) cachedRecords.meta = meta

    return cachedRecords
  }

  /**
   * Gets records from store based on cached query
   *
   * @param {string} type the model type
   * @param {string} url the url that was requested
   * @returns {Array} array of ids
   */
  getCachedIds (type, url) {
    const ids = this.data[type].cache.get(url)
    if (!ids) return []
    const idsSet = new Set(toJS(ids))
    return Array.from(idsSet)
  }

  /**
   * Gets a record from store based on cached query
   *
   * @param {string} type the model type
   * @param {string} id the id to get
   * @returns {object} the cached object
   */
  getCachedId (type, id) {
    return this.data[type].cache.get(String(id))
  }

  /**
   * Helper to look up model class for type.
   *
   * @param {string} type the model type
   * @returns {Function} model constructor
   */
  getKlass (type) {
    return this.models.find((model) => model.type === type)
  }

  /**
   * Creates or updates a model
   *
   * @param {object} data the object will be used to update or create a model
   * @returns {object} the record
   */
  createOrUpdateModelFromData (data) {
    const { id, type } = data

    let record = this.getRecord(type, id)

    if (record) {
      this.updateRecordFromData(record, data)
    } else {
      record = this.createModelFromData(data)
    }

    this.data[type].records.set(String(record.id), record)
    return record
  }

  /**
   * Updates a record from a jsonapi hash
   *
   * @param {object} record a Model record
   * @param {object} data jsonapi-formatted data
   */
  updateRecordFromData (record, data) {
    const tmpId = record.id
    const { id, type, attributes = {}, relationships = {} } = data

    runInAction(() => {
      record.id = String(id)

      // records that are created as inverses are not initialized
      if (!record.initialized) {
        record.initialize(data)
      }

      Object.entries(attributes).forEach(([key, value]) => {
        record[key] = value
      })

      Object.keys(relationships).forEach((relationshipName) => {
        if (relationships[relationshipName].included === false) {
          delete relationships[relationshipName]
        }
      })

      record.relationships = { ...record.relationships, ...relationships }
    })

    record.isInFlight = false
    record.takeSnapshot({ persisted: true })

    runInAction(() => {
      this.data[type].records.set(String(tmpId), record)
      this.data[type].records.set(String(id), record)
    })
  }

  /**
   * Create multiple models from an array of data. It will only build objects
   * with defined models, and ignore everything else in the data.
   *
   * @param {Array} data the array of jsonapi data
   * @returns {Array} an array of the models serialized
   */
  createOrUpdateModelsFromData (data) {
    return data.map((dataObject) => {
      if (this.data[dataObject.type]) {
        return this.createOrUpdateModelFromData(dataObject)
      } else {
        console.warn(`no type defined for ${dataObject.type}`)
        return null
      }
    })
  }

  /**
   * Helper to create a new model
   *
   * @param {object} data id, type, attributes and relationships
   * @param {object} options currently supports `skipInitialization`
   * @returns {object} model instance
   */
  createModelFromData (data, options) {
    const { id, type, attributes = {}, relationships = {} } = data

    const store = this
    const ModelKlass = this.getKlass(type)

    if (!ModelKlass) {
      throw new Error(`Could not find a model for '${type}'`)
    }

    return new ModelKlass({ id, relationships, ...attributes }, store, options)
  }

  /**
   * Defines a resolution for an API call that will update a record or
   * set of records with the data returned from the API
   *
   * @param {Promise} promise a response from the API
   * @param {object|Array} records to be updated
   * @returns {Promise} a resolved promise after operations have been performed
   */
  updateRecordsFromResponse (promise, records) {
    // records may be a single record, if so wrap it in an array to make
    // iteration simpler
    const recordsArray = Array.isArray(records) ? records : [records]
    recordsArray.forEach((record) => {
      record.isInFlight = true
    })

    return promise.then(
      async (response) => {
        const { status } = response

        recordsArray.forEach((record) => {
          record.isInFlight = false
        })

        if (status === 200 || status === 201) {
          const json = await response.json()
          const data = Array.isArray(json.data) ? json.data : [json.data]
          const { included } = json

          if (data.length !== recordsArray.length) {
            throw new Error(
              'Invariant violated: API response data and records to update do not match'
            )
          }

          recordsArray.forEach((record, i) => this.updateRecordFromData(record, data[i]))

          if (included) {
            this.createOrUpdateModelsFromData(included)
          }

          // on success, return the original record(s).
          // again - this may be a single record so preserve the structure
          return records
        } else {
          const errors = await parseErrors(response, this.errorMessages)
          runInAction(() => {
            errors.forEach((error) => {
              const { index, key } = parseErrorPointer(error)
              if (key != null) {
                // add the error to the record
                const errors = recordsArray[index].errors[key] || []
                errors.push(error)
                recordsArray[index].errors[key] = errors
              }
            })
          })

          throw new Error(JSON.stringify(errors))
        }
      },
      function (error) {
        // TODO: Handle error states correctly, including handling errors for multiple targets
        recordsArray.forEach((record) => {
          record.isInFlight = false
        })
        recordsArray[0].errors = error
        throw error
      }
    )
  }
}

export default Store
</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><a href="/" class="sidebar-title sidebar-title-anchor">Home</a><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="7NRo_-Jm7KqI4isjHcwEl"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="FactoryFarm.html">FactoryFarm</a></div><div class="sidebar-section-children"><a href="FactoryFarm.html">FactoryFarm</a></div><div class="sidebar-section-children"><a href="MockServer.html">MockServer</a></div><div class="sidebar-section-children"><a href="Model.html">Model</a></div><div class="sidebar-section-children"><a href="RelatedRecordsArray.html">RelatedRecordsArray</a></div><div class="sidebar-section-children"><a href="Store.html">Store</a></div></div><div class="sidebar-section-title with-arrow" data-isopen="false" id="b4BbqHmDKrCMB8mrPy_yj"><div>Global</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="global.html#QueryString">QueryString</a></div><div class="sidebar-section-children"><a href="global.html#addIncluded">addIncluded</a></div><div class="sidebar-section-children"><a href="global.html#addRelatedRecord">addRelatedRecord</a></div><div class="sidebar-section-children"><a href="global.html#arrayType">arrayType</a></div><div class="sidebar-section-children"><a href="global.html#circularFetchError">circularFetchError</a></div><div class="sidebar-section-children"><a href="global.html#circularFindError">circularFindError</a></div><div class="sidebar-section-children"><a href="global.html#coerceDataToExistingRecord">coerceDataToExistingRecord</a></div><div class="sidebar-section-children"><a href="global.html#combineRacedRequests">combineRacedRequests</a></div><div class="sidebar-section-children"><a href="global.html#dateType">dateType</a></div><div class="sidebar-section-children"><a href="global.html#decrementor">decrementor</a></div><div class="sidebar-section-children"><a href="global.html#defineToManyRelationships">defineToManyRelationships</a></div><div class="sidebar-section-children"><a href="global.html#defineToOneRelationships">defineToOneRelationships</a></div><div class="sidebar-section-children"><a href="global.html#definitionsByDirection">definitionsByDirection</a></div><div class="sidebar-section-children"><a href="global.html#deriveIdQueryStrings">deriveIdQueryStrings</a></div><div class="sidebar-section-children"><a href="global.html#diff">diff</a></div><div class="sidebar-section-children"><a href="global.html#disallowFetches">disallowFetches</a></div><div class="sidebar-section-children"><a href="global.html#fetchWithRetry">fetchWithRetry</a></div><div class="sidebar-section-children"><a href="global.html#getOneFromFactory">getOneFromFactory</a></div><div class="sidebar-section-children"><a href="global.html#incrementor">incrementor</a></div><div class="sidebar-section-children"><a href="global.html#isEmptyString">isEmptyString</a></div><div class="sidebar-section-children"><a href="global.html#isValid">isValid</a></div><div class="sidebar-section-children"><a href="global.html#makeDate">makeDate</a></div><div class="sidebar-section-children"><a href="global.html#mobxAnnotations">mobxAnnotations</a></div><div class="sidebar-section-children"><a href="global.html#mobxAnnotations">mobxAnnotations</a></div><div class="sidebar-section-children"><a href="global.html#newId">newId</a></div><div class="sidebar-section-children"><a href="global.html#numberType">numberType</a></div><div class="sidebar-section-children"><a href="global.html#objectType">objectType</a></div><div class="sidebar-section-children"><a href="global.html#parseErrorPointer">parseErrorPointer</a></div><div class="sidebar-section-children"><a href="global.html#parseErrors">parseErrors</a></div><div class="sidebar-section-children"><a href="global.html#removeRelatedRecord">removeRelatedRecord</a></div><div class="sidebar-section-children"><a href="global.html#requestUrl">requestUrl</a></div><div class="sidebar-section-children"><a href="global.html#serverResponse">serverResponse</a></div><div class="sidebar-section-children"><a href="global.html#setRelatedRecord">setRelatedRecord</a></div><div class="sidebar-section-children"><a href="global.html#simulatePatch">simulatePatch</a></div><div class="sidebar-section-children"><a href="global.html#simulatePost">simulatePost</a></div><div class="sidebar-section-children"><a href="global.html#stringType">stringType</a></div><div class="sidebar-section-children"><a href="global.html#stringifyIds">stringifyIds</a></div><div class="sidebar-section-children"><a href="global.html#toFullJsonapi">toFullJsonapi</a></div><div class="sidebar-section-children"><a href="global.html#validatePresence">validatePresence</a></div><div class="sidebar-section-children"><a href="global.html#validateProperties">validateProperties</a></div><div class="sidebar-section-children"><a href="global.html#validatesArray">validatesArray</a></div><div class="sidebar-section-children"><a href="global.html#validatesArrayPresence">validatesArrayPresence</a></div><div class="sidebar-section-children"><a href="global.html#validatesOptions">validatesOptions</a></div><div class="sidebar-section-children"><a href="global.html#validatesString">validatesString</a></div><div class="sidebar-section-children"><a href="global.html#walk">walk</a></div><div class="sidebar-section-children"><a href="global.html#wrapResponse">wrapResponse</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>